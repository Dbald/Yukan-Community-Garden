<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Yukon Garden AR â€“ Tap to Place</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      #enter-ar-hint {
        position: absolute;
        left: 50%;
        bottom: 16px;
        transform: translateX(-50%);
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.65);
        color: #fff;
        font-size: 14px;
        z-index: 10;
        pointer-events: none;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="enter-ar-hint">
      Tap the AR button. If you see a ring, move your device to find a surface, then tap to place.
    </div>

    <a-scene
      embedded
      renderer="colorManagement: true; physicallyCorrectLights: true"
      webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: body"
      xr-mode-ui="enabled: true; XRMode: ar"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: true"
      devinci-hit-test
    >
      <!-- Camera -->
      <a-entity id="cameraRig">
        <a-entity
          id="camera"
          camera
          position="0 1.6 3"
          wasd-controls-enabled="false"
          look-controls="pointerLockEnabled: false; touchEnabled: true"
        ></a-entity>
      </a-entity>

      <!-- Assets -->
      <a-assets>
        <!-- Update this path if needed -->
        <a-asset-item
          id="garden"
          src="assets/DC_intersection.glb"
        ></a-asset-item>
      </a-assets>

      <!-- Lights -->
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>
      <a-entity
        light="type: directional; intensity: 0.8"
        position="0 4 4"
      ></a-entity>

      <!-- Reticle (for hit-test) -->
      <a-entity
        id="reticle"
        geometry="primitive: ring; radiusInner: 0.15; radiusOuter: 0.2"
        material="color: #00ff99; shader: flat; opacity: 0.9"
        rotation="-90 0 0"
        visible="false"
      ></a-entity>

      <!-- Model: hidden at first; will be shown when placed / fallback triggers -->
      <a-entity
        id="garden-model"
        gltf-model="#garden"
        visible="false"
        scale="0.4 0.4 0.4"
        pinch-scale
      ></a-entity>
    </a-scene>

    <script>
      // devinci-hit-test: tap-to-place with graceful fallback
      AFRAME.registerComponent("devinci-hit-test", {
        init: function () {
          const sceneEl = this.el; // a-scene
          this.xrSession = null;
          this.viewerSpace = null;
          this.refSpace = null;
          this.hitTestSource = null;
          this.useHitTest = false;

          this.reticle = document.querySelector("#reticle");
          this.model = document.querySelector("#garden-model");
          this.hintEl = document.getElementById("enter-ar-hint");

          this._onSelect = this.onSelect.bind(this);

          sceneEl.addEventListener("enter-vr", () => {
            // A-Frame fires enter-vr for AR sessions too
            if (sceneEl.is("ar-mode")) {
              this.startAR();
            }
          });

          sceneEl.addEventListener("exit-vr", () => {
            this.stopAR();
          });
        },

        startAR: async function () {
          const renderer = this.el.renderer;
          if (!renderer || !renderer.xr) {
            console.warn("No WebXR renderer available");
            return;
          }

          const session = renderer.xr.getSession();
          if (!session) {
            console.warn("No XR session");
            return;
          }

          this.xrSession = session;

          // Try to set up hit-test
          try {
            const viewerSpace = await session
              .requestReferenceSpace("viewer")
              .catch(() => null);
            if (!viewerSpace) {
              throw new Error("viewer reference space not supported");
            }

            this.viewerSpace = viewerSpace;
            this.refSpace = await session.requestReferenceSpace("local");

            this.hitTestSource = await session.requestHitTestSource({
              space: this.viewerSpace,
            });

            this.useHitTest = true;
            console.log("Hit-test enabled");

            if (this.hintEl) {
              this.hintEl.textContent =
                "Move your device to find a surface. When you see the ring, tap to place the garden.";
            }
          } catch (e) {
            console.warn("Hit-test not available, using simple placement fallback:", e);
            this.useHitTest = false;

            // Fallback: drop the garden ~2m in front of the camera
            const cam = document.querySelector("#camera");
            if (cam) {
              const camObj = cam.object3D;
              const modelObj = this.model.object3D;

              modelObj.position.set(0, 0, -2); // in front of camera
              camObj.localToWorld(modelObj.position);

              this.model.setAttribute("visible", "true");
            }

            if (this.hintEl) {
              this.hintEl.textContent =
                "AR running (no plane detection on this device). Garden placed in front of you.";
            }
          }

          // Listen for taps (only does something when hit-test is active)
          session.addEventListener("select", this._onSelect);

          // Use our own XR frame loop for hit-test
          const self = this;
          renderer.setAnimationLoop(function (time, frame) {
            if (self.useHitTest) {
              self.onXRFrame(time, frame);
            }
            self.el.render(); // Let A-Frame render the scene
          });
        },

        stopAR: function () {
          if (!this.xrSession) return;
          this.xrSession.removeEventListener("select", this._onSelect);
          this.xrSession = null;
          this.hitTestSource = null;
          this.viewerSpace = null;
          this.refSpace = null;
          this.reticle.setAttribute("visible", "false");
        },

        onXRFrame: function (time, frame) {
          if (!this.useHitTest) return;

          const session = this.xrSession;
          if (!session || !this.hitTestSource) return;

          const referenceSpace = this.refSpace;
          const hitTestResults = frame.getHitTestResults(this.hitTestSource);

          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            if (!pose) return;

            const position = pose.transform.position;
            const orientation = pose.transform.orientation;

            this.reticle.object3D.position.set(
              position.x,
              position.y,
              position.z
            );
            this.reticle.object3D.quaternion.set(
              orientation.x,
              orientation.y,
              orientation.z,
              orientation.w
            );

            this.reticle.setAttribute("visible", "true");
          } else {
            this.reticle.setAttribute("visible", "false");
          }
        },

        onSelect: function () {
          if (!this.useHitTest) return;
          if (!this.reticle.getAttribute("visible")) return;

          const reticleObj = this.reticle.object3D;
          const modelObj = this.model.object3D;

          modelObj.position.copy(reticleObj.position);
          modelObj.quaternion.copy(reticleObj.quaternion);

          this.model.setAttribute("visible", "true");
        },
      });

      AFRAME.registerComponent("pinch-scale", {
    schema: {
      min: { type: "number", default: 0.05 }, // minimum overall scale
      max: { type: "number", default: 5.0 },  // maximum overall scale
    },

    init: function () {
      this.initialDistance = null;
      this.initialScale = 1;
      this.currentScale = this.el.object3D.scale.x;

      this.handleTouchStart = this.onTouchStart.bind(this);
      this.handleTouchMove = this.onTouchMove.bind(this);
      this.handleTouchEnd = this.onTouchEnd.bind(this);

      // Wait until the canvas is ready
      this.el.sceneEl.addEventListener("render-target-loaded", () => {
        const canvas = this.el.sceneEl.canvas;
        if (!canvas) return;

        canvas.addEventListener("touchstart", this.handleTouchStart, { passive: false });
        canvas.addEventListener("touchmove", this.handleTouchMove, { passive: false });
        canvas.addEventListener("touchend", this.handleTouchEnd, { passive: false });
        canvas.addEventListener("touchcancel", this.handleTouchEnd, { passive: false });
      });
    },

    remove: function () {
      const canvas = this.el.sceneEl && this.el.sceneEl.canvas;
      if (!canvas) return;

      canvas.removeEventListener("touchstart", this.handleTouchStart);
      canvas.removeEventListener("touchmove", this.handleTouchMove);
      canvas.removeEventListener("touchend", this.handleTouchEnd);
      canvas.removeEventListener("touchcancel", this.handleTouchEnd);
    },

    getDistance: function (touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    },

    onTouchStart: function (e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        this.initialDistance = this.getDistance(e.touches);
        this.currentScale = this.el.object3D.scale.x; // assuming uniform scale
        this.initialScale = this.currentScale;
      }
    },

    onTouchMove: function (e) {
      if (e.touches.length === 2 && this.initialDistance !== null) {
        e.preventDefault();
        const newDistance = this.getDistance(e.touches);
        const factor = newDistance / this.initialDistance;

        let newScale = this.initialScale * factor;

        // Clamp scale
        const min = this.data.min;
        const max = this.data.max;
        newScale = Math.max(min, Math.min(max, newScale));

        this.el.object3D.scale.set(newScale, newScale, newScale);
      }
    },

    onTouchEnd: function (e) {
      if (e.touches.length < 2) {
        this.initialDistance = null;
      }
    },
  });
    </script>
  </body>
</html>
